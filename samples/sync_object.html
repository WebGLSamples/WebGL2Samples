<!DOCTYPE html>
<!-- Adapted from the OpenGL ES 3.0: Programming Guide, Second Edition, Dan Ginsburg and Budirijanto Purnomo https://github.com/danginsburg/opengles3-book/blob/master/Chapter_14/ParticleSystemTransformFeedback/ParticleSystemTransformFeedback.c -->

<html lang="en">

<head>
    <title>WebGL 2 Samples - sync_object</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <script src="utility.js"></script>
    <script src="third-party/gl-matrix.js"></script>
    <script src="third-party/noise3D.js"></script>
</head>

<body>
    <div id="info">WebGL 2 Samples - sync_object</div>
    <p id="description">Sync objects can be used to synchronize execution between the GL server and the client. In this example, a fenceSync() is created during each transform feedback pass since it can't be reused, then we use waitSync() for all the GL commands in the server to complete before the render pass. gl.deleteSync() does not occur immediately as the sync object will be deleted when no other command operation is waiting for it. Therefore it's safe to call deleteSync() right after waitSync().</p>

    <!-- WebGL 2 shaders -->
    <script id="vs-emit" type="x-shader/x-vertex">
        #version 300 es
        #define POSITION_LOCATION 0
        #define VELOCITY_LOCATION 1
        #define SPAWNTIME_LOCATION 2
        #define LIFETIME_LOCATION 3
        #define ID_LOCATION 4

        precision highp float;
        precision highp int;
        precision highp sampler3D;

        uniform float u_time;
        uniform vec2 u_acceleration;

        layout(location = POSITION_LOCATION) in vec2 a_position;
        layout(location = VELOCITY_LOCATION) in vec2 a_velocity;
        layout(location = SPAWNTIME_LOCATION) in float a_spawntime;
        layout(location = LIFETIME_LOCATION) in float a_lifetime;
        layout(location = ID_LOCATION) in float a_ID;

        out vec2 v_position;
        out vec2 v_velocity;
        out float v_spawntime;
        out float v_lifetime;

        float rand(vec2 co){
            return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
        }

        void main()
        {
            if (a_spawntime == 0.0 || a_position.y < -0.5) {
                // Generate a new particle
                v_position = vec2(0.0, 0.0);
                v_velocity = vec2(rand(vec2(a_ID, 0.0)) - 0.5, rand(vec2(a_ID, a_ID)));
                v_spawntime = u_time;
                v_lifetime = 1.0;
            } else {
                v_velocity = a_velocity + 0.01 * u_acceleration;
                v_position = a_position + 0.01 * v_velocity;
                v_spawntime = a_spawntime;
                v_lifetime = a_lifetime;
            }
        }
    </script>

    <!-- Unsused -->
    <script id="fs-emit" type="x-shader/x-fragment">
        #version 300 es
        precision highp float;
        precision highp int;

        out vec4 color;

        void main()
        {
            color = vec4(1.0);
        }
    </script>

    <script id="vs-draw" type="x-shader/x-vertex">
        #version 300 es
        #define POSITION_LOCATION 0
        #define VELOCITY_LOCATION 1
        #define SPAWNTIME_LOCATION 2
        #define LIFETIME_LOCATION 3

        precision highp float;
        precision highp int;

        uniform float u_time;
        uniform vec2 u_acceleration;

        layout(location = POSITION_LOCATION) in vec2 a_position;
        layout(location = VELOCITY_LOCATION) in vec2 a_velocity;
        layout(location = SPAWNTIME_LOCATION) in float a_spawntime;
        layout(location = LIFETIME_LOCATION) in float a_lifetime;

        void main()
        {
            float deltaTime = u_time - a_spawntime;
            if (deltaTime < a_lifetime) {
                gl_Position = vec4(a_position, 0.0, 1.0);
            } else {
                gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
            }
            gl_PointSize = 10.0;
        }
    </script>

    <script id="fs-draw" type="x-shader/x-fragment">
        #version 300 es
        precision highp float;
        precision highp int;

        uniform vec4 u_color;

        out vec4 color;

        void main()
        {
            color = u_color;
        }
    </script>

    <script>
    (function () {
        'use strict';

        // -- Init Canvas
        var canvas = document.createElement('canvas');
        canvas.width = Math.min(window.innerWidth, window.innerHeight);
        canvas.height = canvas.width;
        document.body.appendChild(canvas);

        // -- Init WebGL Context
        var gl = canvas.getContext('webgl2', { antialias: false });
        var isWebGL2 = !!gl;
        if(!isWebGL2)
        {
            document.getElementById('info').innerHTML = 'WebGL 2 is not available.  See <a href="https://www.khronos.org/webgl/wiki/Getting_a_WebGL_Implementation">How to get a WebGL 2 implementation</a>';
            return;
        }

        canvas.addEventListener("webglcontextlost", function(event) {
            event.preventDefault();
        }, false);

        // -- Declare variables for the particle system

        var NUM_PARTICLES = 200;
        var ACCELERATION = -1.0;

        var time = Date.now();
        var currentSourceIdx = 0;
        var emitSync;

        // -- Init Program

        var PROGRAM_EMIT = 0;
        var PROGRAM_DRAW = 1;

        var programs = initPrograms();

        // Get uniform locations for the transform feedback program
        var emitTimeLocation = gl.getUniformLocation(programs[PROGRAM_EMIT], 'u_time');
        var emitAccelerationLocation = gl.getUniformLocation(programs[PROGRAM_EMIT], 'u_acceleration');

        // Get uniform locations for the draw program
        var drawTimeLocation = gl.getUniformLocation(programs[PROGRAM_DRAW], 'u_time');
        var drawAccelerationLocation = gl.getUniformLocation(programs[PROGRAM_DRAW], 'u_acceleration');
        var drawColorLocation = gl.getUniformLocation(programs[PROGRAM_DRAW], 'u_color');

        // -- Initialize particle data

        var particlePositions = new Float32Array(NUM_PARTICLES * 2);
        var particleVelocities = new Float32Array(NUM_PARTICLES * 2);
        var particleSpawntime = new Float32Array(NUM_PARTICLES);
        var particleLifetime = new Float32Array(NUM_PARTICLES);
        var particleIDs = new Float32Array(NUM_PARTICLES);

        var Particle = {
            POSITION: 0,
            VELOCITY: 1,
            SPAWN_TIME: 2,
            LIFE_TIME: 3,
            ID: 4,
            MAX: 5
        };

        for (var p = 0; p < NUM_PARTICLES; ++p) {
            particlePositions[p * 2] = 0.0;
            particlePositions[p * 2 + 1] = 0.0;
            particleVelocities[p * 2] = 0.0;
            particleVelocities[p * 2 + 1] = 0.0;
            particleSpawntime[p] = 0.0;
            particleLifetime[p] = 0.0;
            particleIDs[p] = p;
        }

        // -- Init Buffer

        var particleVBOs = new Array(2);

        for (var i = 0; i < 2; ++i) {
            particleVBOs[i] = new Array(Particle.MAX);
            for (var j = 0; j < Particle.MAX; ++j) {
                particleVBOs[i][j] = gl.createBuffer();
            }

            gl.bindBuffer(gl.ARRAY_BUFFER, particleVBOs[i][Particle.POSITION]);
            gl.bufferData(gl.ARRAY_BUFFER, particlePositions, gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, particleVBOs[i][Particle.VELOCITY]);
            gl.bufferData(gl.ARRAY_BUFFER, particleVelocities, gl.DYNAMIC_COPY);

            gl.bindBuffer(gl.ARRAY_BUFFER, particleVBOs[i][Particle.SPAWN_TIME]);
            gl.bufferData(gl.ARRAY_BUFFER, particleSpawntime, gl.DYNAMIC_COPY);

            gl.bindBuffer(gl.ARRAY_BUFFER, particleVBOs[i][Particle.LIFE_TIME]);
            gl.bufferData(gl.ARRAY_BUFFER, particleLifetime, gl.DYNAMIC_COPY);

            gl.bindBuffer(gl.ARRAY_BUFFER, particleVBOs[i][Particle.ID]);
            gl.bufferData(gl.ARRAY_BUFFER, particleIDs, gl.STATIC_DRAW);
        }

        // -- Init Vertex Array
        var particleVAOs = [gl.createVertexArray(), gl.createVertexArray()];

        var POSITION_LOCATION = 0;
        var VELOCITY_LOCATION = 1;
        var SPAWNTIME_LOCATION = 2;
        var LIFETIME_LOCATION = 3;
        var ID_LOCATION = 4;

        // -- Init TransformFeedback
        var transformFeedback = gl.createTransformFeedback();

        render();

        function initPrograms() {
            var programEmit = (function(gl, vertexShaderSourceTransform, fragmentShaderSourceTransform) {
                function createShader(gl, source, type) {
                    var shader = gl.createShader(type);
                    gl.shaderSource(shader, source);
                    gl.compileShader(shader);
                    return shader;
                }

                var vshaderTransform = createShader(gl, vertexShaderSourceTransform, gl.VERTEX_SHADER);
                var fshaderTransform = createShader(gl, fragmentShaderSourceTransform, gl.FRAGMENT_SHADER);

                var programEmit = gl.createProgram();
                gl.attachShader(programEmit, vshaderTransform);
                gl.deleteShader(vshaderTransform);
                gl.attachShader(programEmit, fshaderTransform);
                gl.deleteShader(fshaderTransform);

                // Is only limited to 4 varyings?
                var varyings = ['v_position', 'v_velocity', 'v_spawntime', 'v_lifetime'];
                gl.transformFeedbackVaryings(programEmit, varyings, gl.SEPARATE_ATTRIBS);
                gl.linkProgram(programEmit);

                // check
                var log = gl.getProgramInfoLog(programEmit);
                if (log) {
                    console.log(log);
                }

                log = gl.getShaderInfoLog(vshaderTransform);
                if (log) {
                    console.log(log);
                }

                return programEmit;
            })(gl, getShaderSource('vs-emit'), getShaderSource('fs-emit'));

            var programDraw = createProgram(gl, getShaderSource('vs-draw'), getShaderSource('fs-draw'));

            var programs = [programEmit, programDraw];
            return programs;
        }

        function setupVertexAttributes(vaoId, vboArray) {
            gl.bindVertexArray(vaoId);

            gl.bindBuffer(gl.ARRAY_BUFFER, vboArray[Particle.POSITION]);
            gl.vertexAttribPointer(POSITION_LOCATION, 2, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, vboArray[Particle.VELOCITY]);
            gl.vertexAttribPointer(VELOCITY_LOCATION, 2, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, vboArray[Particle.SPAWN_TIME]);
            gl.vertexAttribPointer(SPAWNTIME_LOCATION, 1, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, vboArray[Particle.LIFE_TIME]);
            gl.vertexAttribPointer(LIFETIME_LOCATION, 1, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, vboArray[Particle.ID]);
            gl.vertexAttribPointer(ID_LOCATION, 1, gl.FLOAT, false, 0, 0);

            gl.enableVertexAttribArray(POSITION_LOCATION);
            gl.enableVertexAttribArray(VELOCITY_LOCATION);
            gl.enableVertexAttribArray(SPAWNTIME_LOCATION);
            gl.enableVertexAttribArray(LIFETIME_LOCATION);
            gl.enableVertexAttribArray(ID_LOCATION);
        }

        function emitParticles() {
            time = Date.now();

            var programEmit = programs[PROGRAM_EMIT];

            // Toggle source and destination VBO
            var sourceVBO = particleVBOs[currentSourceIdx];
            var sourceVAO = particleVAOs[currentSourceIdx];

            var destinationVBO = particleVBOs[(currentSourceIdx + 1) % 2];

            gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedback);

            gl.useProgram(programEmit);

            setupVertexAttributes(sourceVAO, sourceVBO);

            // Set transform feedback buffer
            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, destinationVBO[Particle.POSITION]);
            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 1, destinationVBO[Particle.VELOCITY]);
            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 2, destinationVBO[Particle.SPAWN_TIME]);
            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 3, destinationVBO[Particle.LIFE_TIME]);

            // Turn off rasterization - we are not drawing
            gl.enable(gl.RASTERIZER_DISCARD);

            // Set uniforms
            gl.uniform1f(emitTimeLocation, time);
            gl.uniform2f(emitAccelerationLocation, 0.0, ACCELERATION);

            // Emit particles using transform feedback
            gl.beginTransformFeedback(gl.POINTS);
            gl.drawArrays(gl.POINTS, 0, NUM_PARTICLES);
            gl.endTransformFeedback();

            // Create a sync object to ensure transform feedback results
            // are completed before the draw that uses them.
            // Sync object can't be reused so we create a new one for each synchronization operation.
            // Not recommended to use gl.finish unless neccessary for synchronizing all your operation as it could severely reduce the GPU performance. Instead use sync object as you can wait for partial completion of the GL command stream.
            emitSync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);

            // Restore state
            gl.disable(gl.RASTERIZER_DISCARD);
            gl.useProgram(null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);
            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 1, null);
            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 2, null);
            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 3, null);
            gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);

            // Ping pong the buffers
            currentSourceIdx = (currentSourceIdx + 1) % 2;
        }

        function render() {
            // Spawn particles
            emitParticles();

            time = Date.now();

            // Block the GL server until transform feedback results are completed
            gl.waitSync(emitSync, 0, gl.TIMEOUT_IGNORED);

            // gl.deleteSync() does not occur immediately as the sync object will
            // be deleted when no other command operation is waiting for it.
            // Therefore it's safe to call deleteSync() here.
            gl.deleteSync(emitSync);

            // Set the viewport
            gl.viewport(0, 0, canvas.width, canvas.height - 10);

            // Clear color buffer
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            setupVertexAttributes(particleVAOs[currentSourceIdx], particleVBOs[currentSourceIdx]);

            gl.useProgram(programs[PROGRAM_DRAW]);

            // Set uniforms
            gl.uniform1f(drawTimeLocation, time);
            gl.uniform4f(drawColorLocation, 0.0, 1.0, 1.0, 1.0);
            gl.uniform2f(drawAccelerationLocation, 0.0, ACCELERATION);

            // Enable blending
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);

            gl.drawArrays(gl.POINTS, 0, NUM_PARTICLES);

            requestAnimationFrame(render);
        }

        window.onunload = function() {
            // -- Delete WebGL resources
            gl.deleteTransformFeedback(transformFeedback);
            gl.deleteProgram(programs[PROGRAM_EMIT]);
            gl.deleteProgram(programs[PROGRAM_DRAW]);
            for (var i = 0; i < 2; ++i) {
                for (var j = 0; j < Particle.MAX; ++j) {
                    gl.deleteBuffer(particleVBOs[i][j]);
                }
            }
            gl.deleteVertexArray(particleVAOs[PROGRAM_EMIT]);
            gl.deleteVertexArray(particleVAOs[PROGRAM_DRAW]);
        };
    })();
    </script>

</body>

</html>
